//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//

#include "NSDetectorConstruction.hh"
#include "NSDetectorMessenger.hh"

#include "NSSD.hh"
#include "G4SDManager.hh"

#include "G4Material.hh"
#include "G4NistManager.hh"

#include "G4Box.hh"
#include "G4LogicalVolume.hh"
#include "G4PVPlacement.hh"

#include "G4GeometryManager.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4SolidStore.hh"

#include "G4SystemOfUnits.hh"
#include "G4PhysicalConstants.hh"
#include "G4VisAttributes.hh"

#include "G4RunManager.hh"

NSDetectorConstruction::NSDetectorConstruction()
: G4VUserDetectorConstruction(),
  world_mat   (0), shield1_mat (0), shield2_mat(0), det_mat(0),
  solidWorld  (0), logicWorld  (0), physWorld  (0),
  solidShield1(0), logicShield1(0), physShield1(0),
  solidShield2(0), logicShield2(0), physShield2(0),
  solidDet    (0), logicDet    (0), physDet    (0)
{
  // Default parameters
  shield1_sizeXY = 1.0*m;
  shield1_sizeZ  = 1.0*m;
  shield2Ratio   = 0.7;
  detRatio       = 0.5;
  ComputeParameters();

  // Default materials
  DefineMaterials();
  SetWorldMat("G4_AIR");
  SetShield1Mat("G4_Pb");
  SetShield2Mat("BdP5_0");
  SetDetMat("lXe");

  // Commands for interactive definition of detector
  fMessenger = new NSDetectorMessenger(this);
}

NSDetectorConstruction::~NSDetectorConstruction()
{
  delete fMessenger;
}

G4VPhysicalVolume* NSDetectorConstruction::Construct()
{
  return ConstructDetector();
}

void NSDetectorConstruction::DefineMaterials()
{
  // Get NIST manager
  G4NistManager* nistManager = G4NistManager::Instance();
  
  // Generic Materials defined from NIST database
  nistManager->FindOrBuildMaterial("G4_AIR");
  nistManager->FindOrBuildMaterial("G4_Galactic");

  // Shielding Materials

  // Materials defined from NIST database
  nistManager->FindOrBuildMaterial("G4_Pb");
  G4Material* polyethylene = nistManager->FindOrBuildMaterial("G4_POLYETHYLENE");

  // Boron defined as an element from isotopes
  G4double percentB10 = 19.9;
  G4Isotope* B10 = new G4Isotope("B10", 5, 10, 10.012937*g/mole);
  G4Isotope* B11 = new G4Isotope("B11", 5, 11, 11.009305*g/mole);
  G4Element* boron = new G4Element("boron", "B", 2);
  boron->AddIsotope(B10, percentB10*perCent);
  boron->AddIsotope(B11, (100-percentB10)*perCent);

  // Boron-doped polyethylene (BdP) defined as a material
  G4double densityBdP = 1.01*g/cm3;
  G4double percentBdP;

  // 0.1 %
  percentBdP = 0.1;
  G4Material* BdP0_1 = new G4Material("BdP0_1", densityBdP, 2);
  BdP0_1->AddElement(boron, percentBdP*perCent);
  BdP0_1->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 0.2 %
  percentBdP = 0.2;
  G4Material* BdP0_2 = new G4Material("BdP0_2", densityBdP, 2);
  BdP0_2->AddElement(boron, percentBdP*perCent);
  BdP0_2->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 0.4 %
  percentBdP = 0.4;
  G4Material* BdP0_4 = new G4Material("BdP0_4", densityBdP, 2);
  BdP0_4->AddElement(boron, percentBdP*perCent);
  BdP0_4->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 0.6 %
  percentBdP = 0.6;
  G4Material* BdP0_6 = new G4Material("BdP0_6", densityBdP, 2);
  BdP0_6->AddElement(boron, percentBdP*perCent);
  BdP0_6->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 0.8 %
  percentBdP = 0.8;
  G4Material* BdP0_8 = new G4Material("BdP0_8", densityBdP, 2);
  BdP0_8->AddElement(boron, percentBdP*perCent);
  BdP0_8->AddMaterial(polyethylene, (100-percentBdP)*perCent);


  // 1.0 %
  percentBdP = 1.0;
  G4Material* BdP1_0 = new G4Material("BdP1_0", densityBdP, 2);
  BdP1_0->AddElement(boron, percentBdP*perCent);
  BdP1_0->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 1.2 %
  percentBdP = 1.2;
  G4Material* BdP1_2 = new G4Material("BdP1_2", densityBdP, 2);
  BdP1_2->AddElement(boron, percentBdP*perCent);
  BdP1_2->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 1.4 %
  percentBdP = 1.4;
  G4Material* BdP1_4 = new G4Material("BdP1_4", densityBdP, 2);
  BdP1_4->AddElement(boron, percentBdP*perCent);
  BdP1_4->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 1.6 %
  percentBdP = 1.6;
  G4Material* BdP1_6 = new G4Material("BdP1_6", densityBdP, 2);
  BdP1_6->AddElement(boron, percentBdP*perCent);
  BdP1_6->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 1.8 %
  percentBdP = 1.8;
  G4Material* BdP1_8 = new G4Material("BdP1_8", densityBdP, 2);
  BdP1_8->AddElement(boron, percentBdP*perCent);
  BdP1_8->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 2.0 %
  percentBdP = 2.0;
  G4Material* BdP2_0 = new G4Material("BdP2_0", densityBdP, 2);
  BdP2_0->AddElement(boron, percentBdP*perCent);
  BdP2_0->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 2.2 %
  percentBdP = 2.2;
  G4Material* BdP2_2 = new G4Material("BdP2_2", densityBdP, 2);
  BdP2_2->AddElement(boron, percentBdP*perCent);
  BdP2_2->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 2.4 %
  percentBdP = 2.4;
  G4Material* BdP2_4 = new G4Material("BdP2_4", densityBdP, 2);
  BdP2_4->AddElement(boron, percentBdP*perCent);
  BdP2_4->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 2.6 %
  percentBdP = 2.6;
  G4Material* BdP2_6 = new G4Material("BdP2_6", densityBdP, 2);
  BdP2_6->AddElement(boron, percentBdP*perCent);
  BdP2_6->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 2.8 %
  percentBdP = 2.8;
  G4Material* BdP2_8 = new G4Material("BdP2_8", densityBdP, 2);
  BdP2_8->AddElement(boron, percentBdP*perCent);
  BdP2_8->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 3.0 %
  percentBdP = 3.0;
  G4Material* BdP3_0 = new G4Material("BdP3_0", densityBdP, 2);
  BdP3_0->AddElement(boron, percentBdP*perCent);
  BdP3_0->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 3.2 %
  percentBdP = 3.2;
  G4Material* BdP3_2 = new G4Material("BdP3_2", densityBdP, 2);
  BdP3_2->AddElement(boron, percentBdP*perCent);
  BdP3_2->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 3.4 %
  percentBdP = 3.4;
  G4Material* BdP3_4 = new G4Material("BdP3_4", densityBdP, 2);
  BdP3_4->AddElement(boron, percentBdP*perCent);
  BdP3_4->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 3.6 %
  percentBdP = 3.6;
  G4Material* BdP3_6 = new G4Material("BdP3_6", densityBdP, 2);
  BdP3_6->AddElement(boron, percentBdP*perCent);
  BdP3_6->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 3.8 %
  percentBdP = 3.8;
  G4Material* BdP3_8 = new G4Material("BdP3_8", densityBdP, 2);
  BdP3_8->AddElement(boron, percentBdP*perCent);
  BdP3_8->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 4.0 %
  percentBdP = 4.0;
  G4Material* BdP4_0 = new G4Material("BdP4_0", densityBdP, 2);
  BdP4_0->AddElement(boron, percentBdP*perCent);
  BdP4_0->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 4.2 %
  percentBdP = 4.2;
  G4Material* BdP4_2 = new G4Material("BdP4_2", densityBdP, 2);
  BdP4_2->AddElement(boron, percentBdP*perCent);
  BdP4_2->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 4.4 %
  percentBdP = 4.4;
  G4Material* BdP4_4 = new G4Material("BdP4_4", densityBdP, 2);
  BdP4_4->AddElement(boron, percentBdP*perCent);
  BdP4_4->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 4.6 %
  percentBdP = 4.6;
  G4Material* BdP4_6 = new G4Material("BdP4_6", densityBdP, 2);
  BdP4_6->AddElement(boron, percentBdP*perCent);
  BdP4_6->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 4.8 %
  percentBdP = 4.8;
  G4Material* BdP4_8 = new G4Material("BdP4_8", densityBdP, 2);
  BdP4_8->AddElement(boron, percentBdP*perCent);
  BdP4_8->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // 5.0 %
  percentBdP = 5.0;
  G4Material* BdP5_0 = new G4Material("BdP5_0", densityBdP, 2);
  BdP5_0->AddElement(boron, percentBdP*perCent);
  BdP5_0->AddMaterial(polyethylene, (100-percentBdP)*perCent);

  // Detector Materials

  // Liquid xenon defined as a material
  new G4Material("lXe", 54, 131.293*g/mole, 3*g/cm3);

  // Germanium defined from NIST database
  nistManager->FindOrBuildMaterial("G4_Ge");

  // Cesium iodide defined from elements
  G4Element* cesium = new G4Element("cesium", "Cs", 55, 132.90545*g/mole);
  G4Element* iodine = new G4Element("iodine", "I", 53, 126.90447*g/mole);
  G4double densityCsI = 4.510*g/cm3;
  G4Material* CsI = new G4Material("CsI", densityCsI, 2);
  CsI->AddElement(cesium, 1);
  CsI->AddElement(iodine, 1);

  // Liquid argon defined as a material
  new G4Material("lAr", 18, 39.948*g/mole, 1.40*g/cm3);
}

G4VPhysicalVolume* NSDetectorConstruction::ConstructDetector()
{
  // Clean old geometry, if any
  G4GeometryManager::GetInstance()->OpenGeometry();
  G4PhysicalVolumeStore::GetInstance()->Clean();
  G4LogicalVolumeStore::GetInstance()->Clean();
  G4SolidStore::GetInstance()->Clean();

  // Complete parameters defintion
  ComputeParameters();

  // Option to switch on/off checking of volumes overlaps
  G4bool checkOverlaps = true;

  // World
  solidWorld =
    new G4Box("World",                          // name
              0.5*world_sizeXY,                 // size x
              0.5*world_sizeXY,                 // size y
              0.5*world_sizeZ);                 // size z

  logicWorld =
    new G4LogicalVolume(solidWorld,             // solid
                        world_mat,              // material
                        "World");               // name

  physWorld = 
    new G4PVPlacement(0,                        // no rotation
                      G4ThreeVector(),          // at (0,0,0)
                      logicWorld,               // logical volume
                      "World",                  // name
                      0,                        // mother  volume
                      false,                    // no boolean operation
                      0,                        // copy number
                      checkOverlaps);           // overlaps checking

  // Shield1
  solidShield1=0; logicShield1=0; physShield1=0;
  solidShield1 =
    new G4Box("Shield1",                        // name
              0.5*shield1_sizeXY,               // size x
              0.5*shield1_sizeXY,               // size y
              0.5*shield1_sizeZ);               // size z

  logicShield1 =
    new G4LogicalVolume(solidShield1,           // solid
                        shield1_mat,            // material
                        "Shield1");             // name

  physShield1 =
    new G4PVPlacement(0,                        // no rotation
                    G4ThreeVector(),            // at (0, 0, 0)
                    logicShield1,               // logical volume
                    "Shield1",                  // name
                    logicWorld,                 // mother volume
                    false,                      // no boolean operation
                    0,                          // copy number
                    checkOverlaps);             // overlaps checking    

  // Shield2
  solidShield2=0; logicShield2=0; physShield2=0;
  solidShield2 =
    new G4Box("Shield2",                        // name
              0.5*shield2_sizeXY,               // size x
              0.5*shield2_sizeXY,               // size y
              0.5*shield2_sizeZ);               // size z

  logicShield2 =
    new G4LogicalVolume(solidShield2,           // solid
                        shield2_mat,            // material
                        "Shield2");             // name

  physShield2 =
    new G4PVPlacement(0,                        // no rotation
                    G4ThreeVector(),            // at (0,0,0)
                    logicShield2,               // logical volume
                    "Shield2",                  // name
                    logicShield1,               // mother  volume
                    false,                      // no boolean operation
                    0,                          // copy number
                    checkOverlaps);             // overlaps checking

  // Detector
  solidDet=0; logicDet=0; physDet=0;
  solidDet =
    new G4Box("Det",                            // name
              0.5*det_sizeXY,      // size x
              0.5*det_sizeXY,      // size y
              0.5*det_sizeZ);      // size z

  logicDet =
    new G4LogicalVolume(solidDet,               // solid
                        det_mat,                // material
                        "Det");                 // name

  physDet =
    new G4PVPlacement(0,                        // no rotation
                      G4ThreeVector(),          // at (0, 0, 0)
                      logicDet,                 // logical volume
                      "Det",                    // name
                      logicShield2,             // mother volume
                      false,                    // no boolean operation
                      0,                        // copy number
                      checkOverlaps);           // overlaps checking

  // Print volumes
  G4cout << "volumes: " << logicDet << " " << logicShield2 << " "
         << logicShield1 << " " << logicWorld << G4endl;

  // Make world box invisible
  logicWorld->SetVisAttributes (G4VisAttributes::Invisible);

  // Always return the physical World
  return physWorld;
}

void NSDetectorConstruction::ConstructSDandField()
{
  // Create new sensitive detector
  cennsSD = new NSSD("cennsSD", "CennsHitsCollection");

  // Assign sensitive detector to Det volume
  SetSensitiveDetector("Det", cennsSD);
}

void NSDetectorConstruction::SetShield1Size(G4double size)
{
  // Check that box has been constructed
  if (!solidShield1) 
  {
    G4cerr << "Detector has not yet been constructed." << G4endl;
    return;
  }

  // Check that size is greater than zero
  if (size < 0)
  { 
    G4cout << "Size " << size
           << " less than zero!  No change to geometry." << G4endl;
    return;
  }

  // Set new shield1 size
  shield1_sizeXY = size;
  shield1_sizeZ = size;

  G4cout << "Shield1 size set: " << shield1_sizeXY/m << " m" << G4endl;
}

void NSDetectorConstruction::SetShield2Ratio(G4double ratio)
{
  // Check that shield 2 has been constructed
  if (!solidShield2) 
  {
    G4cerr << "Detector has not yet been constructed." << G4endl;
    return;
  }

  // Check that new shield2 ratio is between 0 and 1
  if (ratio < 0. || ratio > 1.)
  { 
    G4cout << "Invalid shield2 ratio " << ratio
           << "!  No change to geometry." << G4endl;
    return;
  }

  // Check that new shield2 ratio is larger than detector ratio
  if (ratio < detRatio)
  { 
    G4cout << "Shield2 ratio " << ratio
           << " less than detector ratio!  No change to geometry." << G4endl;
    return;
  }

  // Set new sheild2 ratio
  shield2Ratio = ratio;

  G4cout << "Shield2 ratio set: " << shield2Ratio << G4endl;
}

void NSDetectorConstruction::SetDetRatio(G4double ratio)
{
  // Check that detector has been constructed
  if (!solidDet) 
  {
    G4cerr << "Detector has not yet been constructed." << G4endl;
    return;
  }

  // Check that new detector ratio is between 0 and 1
  if (ratio < 0. || ratio > 1.)
  {
    G4cout << "Invalid detector ratio " << ratio
           << "!  No change to geometry." << G4endl;
    return;
  }

  // Check that new detector ratio is smaller than shield2 ratio
  if (ratio > shield2Ratio)
  { 
    G4cout << "Detector ratio " << ratio
           << " greater than shield2 ratio!  No change to geometry." << G4endl;
    return;
  }

  // Set new detector ratio
  detRatio = ratio;

  G4cout << "Detector ratio set: " << detRatio << G4endl;
}

void NSDetectorConstruction::SetWorldMat(G4String materialChoice)
{
  // search the material by its name   
  G4Material* pttoMaterial = G4Material::GetMaterial(materialChoice);     
  if (pttoMaterial) world_mat = pttoMaterial;
}

void NSDetectorConstruction::SetShield1Mat(G4String materialChoice)
{
  // search the material by its name   
  G4Material* pttoMaterial = G4Material::GetMaterial(materialChoice);     
  if (pttoMaterial) shield1_mat = pttoMaterial;
}

void NSDetectorConstruction::SetShield2Mat(G4String materialChoice)
{
  // search the material by its name   
  G4Material* pttoMaterial = G4Material::GetMaterial(materialChoice);     
  if (pttoMaterial) shield2_mat = pttoMaterial;
}

void NSDetectorConstruction::SetDetMat(G4String materialChoice)
{
  // search the material by its name   
  G4Material* pttoMaterial = G4Material::GetMaterial(materialChoice);     
  if (pttoMaterial) det_mat = pttoMaterial;
}

void NSDetectorConstruction::UpdateGeometry()
{
  // Completely reconstruct detector
  G4RunManager::GetRunManager()->DefineWorldVolume(ConstructDetector());

  // Reset sensitive detector
  SetSensitiveDetector("Det", cennsSD);
}

